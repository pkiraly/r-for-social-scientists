#' Presentation of the SAFI Data
#' SAFI (Studying African Farmer-Led Irrigation) is a study looking at farming
#'   and irrigation methods in Tanzania and Mozambique.
#' interviews conducted between November 2016 and June 2017

#' read_csv() from the readr package which is part of the tidyverse
#' load the package
library(tidyverse)
library(here)

#' missing data is encoded as “NULL” in the dataset
interviews <- read_csv(
  here("data", "SAFI_clean.csv"),
  na = "NULL")

#' alternative reading functions:
#' read_csv2() — uses ; for the field separator and , for the decimal point
#' read_tsv() — TAB separated
#' read_delim() — use other separators

#' watch the data
interviews
view(interviews)
head(interviews)

# A tibble: 131 x 14
#key_ID village interview_date      no_membrs years_liv respondent_wall…
#<dbl> <chr>   <dttm>                  <dbl>     <dbl> <chr>           
#  ...
# … with 121 more rows, and 8 more variables: rooms <dbl>,
#   memb_assoc <chr>, affect_conflicts <chr>, liv_count <dbl>,

class(interviews)


#' What are data frames and tibbles?
#' - de facto data structure for tabular data
#' - columns are vectors that all have the same length
#' - each column must contain a single type of data (e.g., characters, integers, factors)
#' - most commonly they are generated by the functions read_csv() or read_table()
#'   (Read whitespace-separated columns into a tibble)
#' - tibble is an extension of R data frames used by the tidyverse

#' Inspecting data frames
#' Size:
#' returns a vector with the number of rows in the first element, and the number of
#' columns as the second element (the dimensions of the object)
dim(interviews)

#' the number of rows
nrow(interviews)
#' the number of columns
ncol(interviews)

#' Content:
# the first 6 rows
head(interviews)
# the last 6 rows
tail(interviews)

# the column names (synonym of colnames() for data.frame objects)
names(interviews)

#' Summary:
#' structure of the object and information about the class, length and content of each column
str(interviews)

#' summary statistics for each column
summary(interviews)

#' the number of columns and rows of the tibble, the names and class of each column,
#' and previews as many values will fit on the screen.
glimpse(interviews)

#' Indexing and subsetting data frames
#' 1st row, 1st column
interviews[1, 1]

#' first element in the 6th column of the tibble
interviews[1, 6]

# first column of the data frame (as a vector)
interviews[[1]]

# first column of the data frame (as a data.frame)
interviews[1]

# first three elements in the 7th column of the tibble
interviews[1:3, 7]

# the 3rd row of the data frame (as a data.frame)
interviews[3, ]

#' : is a special function that creates numeric vectors of integers in increasing
#' or decreasing order, test 1:10 and 10:1 for instance.

# equivalent to head_interviews <- head(interviews)
head_interviews <- interviews[1:6, ]

# The whole tibble, except the first column
interviews[, -1]

# Equivalent to head(interviews)
interviews[-c(7:131), ]

# Result is a tibble
interviews["village"]
interviews[, "village"]

# Result is a vector
interviews[["village"]]
interviews$village

#' ++ Exercise ++
#' 
#' 1. Create a tibble (interviews_100) containing only the data in row 100
#'    of the interviews dataset.
#'    
#' 2. Notice how nrow() gave you the number of rows in the tibble?
#'  - Use that number to pull out just that last row in the tibble.
#'  - Compare that with what you see as the last row using tail() to make
#'    sure it’s meeting expectations.
#'  - Pull out that last row using nrow() instead of the row number.
#'  - Create a new tibble (interviews_last) from that last row.
#' 
#' 3. Using the number of rows in the interviews dataset that you found
#'    in question 2, extract the row that is in the middle of the dataset.
#'    Store the content of this middle row in an object named 
#'    interviews_middle. (hint: This dataset has an odd number of rows,
#'    so finding the middle is a bit trickier than dividing n_rows by 2.
#'    Use the median() function and what you’ve learned about sequences
#'    in R to extract the middle row!
#'    
#' 4. Combine nrow() with the - notation above to reproduce the behavior
#'    of head(interviews), keeping just the first through 6th rows of
#'    the interviews dataset.

#' Factors
#' - deal with categorical data
#' - stored as integers associated with labels
#' - can be ordered or unordered
#' - Once created, factors can only contain a pre-defined set of values,
#'   known as levels
#' - by default, R always sorts levels in alphabetical order

respondent_floor_type <- factor(c("earth", "cement", "cement", "earth"))

# get levels
levels(respondent_floor_type)
# number of levels
nlevels(respondent_floor_type)

# current order
respondent_floor_type

respondent_floor_type <- factor(respondent_floor_type, 
                                levels = c("earth", "cement"))

# after re-ordering
respondent_floor_type

levels(respondent_floor_type)

# change category
respondent_floor_type <- fct_recode(respondent_floor_type, brick = "cement")
levels(respondent_floor_type)

respondent_floor_type

# So far, factor is unordered, like a nominal variable
# make it ordered
respondent_floor_type_ordered <- factor(respondent_floor_type, 
                                        ordered = TRUE)
# after setting as ordered factor
respondent_floor_type_ordered

#' Converting factors
# convert a factor to a character vector
as.character(respondent_floor_type)

year_fct <- factor(c(1990, 1983, 1977, 1998, 1990))

# Wrong! And there is no warning...
as.numeric(year_fct)

# Works...
as.numeric(as.character(year_fct))

# recommended way to convert a numeric factor to numeric vector
as.numeric(levels(year_fct))[year_fct]

# steps:
#' 1. obtain all the factor levels
levels(year_fct) 
#' 2. convert these levels to numeric values
as.numeric(levels(year_fct)) 
#' 3. access these numeric values using the underlying integers of the
#'  vector year_fct inside the square brackets
as.numeric(levels(year_fct))[year_fct]

#' Renaming factors
#' plot() — get a quick glance at the number of observations

#' create a vector from the data frame column "memb_assoc"
memb_assoc <- interviews$memb_assoc

# convert it into a factor
memb_assoc <- as.factor(memb_assoc)
memb_assoc

# bar plot of the number of interview respondents who were
# members of irrigation association:
plot(memb_assoc)

#' change NA to "undetermined"

# Let's recreate the vector from the data frame column "memb_assoc"
memb_assoc <- interviews$memb_assoc

# replace the missing data with "undetermined"
memb_assoc[is.na(memb_assoc)] <- "undetermined"

# convert it into a factor
memb_assoc <- as.factor(memb_assoc)
# let's see what it looks like
memb_assoc

## bar plot of the number of interview respondents who were
## members of irrigation association:
plot(memb_assoc)

#' ++ Exercise ++
#' 1. Rename the levels of the factor to have the first letter in uppercase:
#'    “No”,”Undetermined”, and “Yes”.
#'    
#' 2. Now that we have renamed the factor level to “Undetermined”, can you recreate
#'    the barplot such that “Undetermined” is last (after “Yes”)?

#' Formatting Dates
#' check interview_date column
str(interviews)

#' lubridate package. Part of tydiverse, but not loaded by default
library(lubridate)
#' ymd() — takes a vector representing year, month, and day, and converts it to a Date vector

dates <- interviews$interview_date
str(dates)
interviews$day <- day(dates)
interviews$month <- month(dates)
interviews$year <- year(dates)
interviews

char_dates <- c("7/31/2012", "8/9/2014", "4/30/2016")
str(char_dates)
as_date(char_dates, format = "%m/%d/%Y") # good
as_date(char_dates, format = "%m/%d/%y") # small y (year in 2 chars)
as_date(char_dates, format = "%d/%m/%y") # day/month

#' ymd(), mdy() or dmy() to convert character variables to date.
mdy(char_dates)

#' Key Points
#' - Use read_csv to read tabular data in R.
#' - Use factors to represent categorical data in R.

